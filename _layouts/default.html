<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ page.title }} | {{ site.title }}</title>
    <meta name="description" content="{{ site.description }}">
    <link rel="stylesheet" href="{{ site.baseurl }}/assets/css/style.css?v={{ site.time | date: '%s' }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="{{ site.baseurl }}/assets/images/favicon.ico">
</head>

<body>

    <header class="site-header">
        <div class="container">
            <a href="{{ site.baseurl }}/" class="site-logo">
                <img src="{{ site.baseurl }}/assets/images/logo.png" alt="KubeDesk Logo" class="logo-img">
                KubeDesk
            </a>
            <nav class="site-nav">
                <a href="https://github.com/akkezi/KubeDesk" target="_blank">GitHub</a>
                <a href="{{ site.baseurl }}/docs">Docs</a>
            </nav>
        </div>
    </header>

    <main class="page-content" aria-label="Content">
        {{ content }}
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; {{ site.time | date: "%Y" }} KubeDesk. All rights reserved.</p>
            <div class="footer-links">
                <a href="#">Privacy</a>
                <a href="#">Terms</a>
                <a href="https://github.com/akkezi/KubeDesk">GitHub</a>
            </div>
        </div>
    </footer>

    <footer class="site-footer">
        <div class="container">
            <div class="footer-links">
                <a href="https://github.com/akkezi/KubeDesk" target="_blank">GitHub</a>
                <a href="#">Documentation</a>
                <a href="https://github.com/akkezi/KubeDesk/issues" target="_blank">Report an Issue</a>
            </div>
            <p style="color: #484f58; font-size: 0.85rem;">&copy; {{ site.time | date: '%Y' }} KubeDesk</p>
        </div>
    </footer>

    <!-- Lightbox Modal -->
    <!-- Lightbox Modal -->
    <div id="lightbox" class="lightbox">
        <span class="lightbox-close" onclick="closeLightbox()">&times;</span>
        <a class="prev" onclick="changeSlide(-1)">&#10094;</a>
        <img class="lightbox-content" id="lightbox-img">
        <a class="next" onclick="changeSlide(1)">&#10095;</a>
    </div>

    <script>
        let currentIndex = 0;

        function openLightbox(imgElement) {
            const lightbox = document.getElementById("lightbox");
            const allImages = Array.from(document.querySelectorAll('.gallery-scroll img'));

            currentIndex = allImages.indexOf(imgElement);
            updateLightboxImage();

            lightbox.style.display = "flex";
            document.body.style.overflow = "hidden"; // Prevent scrolling
        }

        function closeLightbox() {
            document.getElementById("lightbox").style.display = "none";
            document.body.style.overflow = "auto"; // Restore scrolling
        }

        function changeSlide(n) {
            const allImages = document.querySelectorAll('.gallery-scroll img');
            currentIndex += n;
            if (currentIndex >= allImages.length) currentIndex = 0;
            if (currentIndex < 0) currentIndex = allImages.length - 1;
            updateLightboxImage();
        }

        function updateLightboxImage() {
            const allImages = document.querySelectorAll('.gallery-scroll img');
            const lightboxImg = document.getElementById("lightbox-img");
            // Add check to ensure images exist
            if (allImages.length > 0) {
                lightboxImg.src = allImages[currentIndex].src;
            }
        }

        // Close on click OUTSIDE image (on background)
        document.getElementById('lightbox').addEventListener('click', function (e) {
            if (e.target === this) {
                closeLightbox();
            }
        });

        // Keydown events
        document.addEventListener('keydown', function (event) {
            if (document.getElementById("lightbox").style.display === "flex") {
                if (event.key === "Escape") closeLightbox();
                if (event.key === "ArrowLeft") changeSlide(-1);
                if (event.key === "ArrowRight") changeSlide(1);
            }
        });

        // App Simulator Logic
        // App Simulator Logic
        function switchTab(element, categoryId) {
            // Remove active class from all sidebar items
            document.querySelectorAll('.sidebar-item').forEach(item => {
                item.classList.remove('active');
            });

            // Remove active class from all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // Add active class to clicked item
            element.classList.add('active');

            // Show target content
            const targetContent = document.getElementById(categoryId);
            targetContent.classList.add('active');

            // Trigger Randomization
            randomizeCards(targetContent);
        }

        function randomizeCards(container) {
            requestAnimationFrame(() => {
                const cards = Array.from(container.querySelectorAll('.content-card'));
                const isMobile = window.innerWidth <= 768;

                // Adjust grid based on screen size
                const count = cards.length;
                let cols = 4;
                let rows = 4;

                // Desktop Grid Logic
                if (!isMobile) {
                    if (count <= 6) { cols = 3; rows = 2; }
                    else if (count <= 10) { cols = 4; rows = 3; }

                    const slots = [];
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            slots.push({ x: c, y: r });
                        }
                    }
                    slots.sort(() => Math.random() - 0.5);

                    cards.forEach((card, index) => {
                        card.classList.remove('visible');
                        makeDraggable(card);

                        if (index < slots.length) {
                            const slot = slots[index];
                            const stepX = 90 / cols;
                            const stepY = 80 / rows;

                            const BaseX = 5 + (slot.x * stepX);
                            const BaseY = 10 + (slot.y * stepY);

                            const offsetX = (Math.random() - 0.5) * 15;
                            const offsetY = (Math.random() - 0.5) * 15;

                            card.style.left = Math.max(0, Math.min(90, BaseX + offsetX)) + '%';
                            card.style.top = Math.max(0, Math.min(90, BaseY + offsetY)) + '%';

                            applyAnimation(card, false);

                            setTimeout(() => { card.classList.add('visible'); }, index * 30);
                        }
                    });
                } else {
                    // MOBILE: Deterministic "Zoned" Distribution
                    // 1. Shuffle cards to mix content positions
                    cards.sort(() => Math.random() - 0.5);

                    // 2. Split into 2 columns for better spread
                    const col1 = [];
                    const col2 = [];
                    cards.forEach((card, i) => {
                        if (i % 2 === 0) col1.push(card);
                        else col2.push(card);
                    });

                    // 3. Helper to position a column
                    const distributeColumn = (items, xMin, xMax) => {
                        const rowHeight = 90 / items.length; // Divide 90% height by item count
                        items.forEach((card, i) => {
                            card.classList.remove('visible');
                            makeDraggable(card);

                            // Vertical: Guaranteed slot + random jitter
                            // e.g., if 4 items: 0-22%, 22-45%, 45-67%, 67-90%
                            const BaseY = (i * rowHeight) + 2; // +2% padding/offset
                            const JitterY = Math.random() * (rowHeight * 0.4); // Jitter up to 40% of slot height
                            const Top = BaseY + JitterY;

                            // Horizontal: Random within column bounds
                            const Left = xMin + (Math.random() * (xMax - xMin));

                            card.style.top = Top + '%';
                            card.style.left = Left + '%';

                            applyAnimation(card, true);
                            setTimeout(() => { card.classList.add('visible'); }, i * 50);
                        });
                    };

                    // Left Column (0% - 40%)
                    distributeColumn(col1, 0, 40);
                    // Right Column (50% - 90%)
                    distributeColumn(col2, 50, 95);
                }
            });
        }

        function applyAnimation(card, isMobile) {
            const anims = ['float', 'float1', 'float2', 'float3'];
            const randomAnim = anims[Math.floor(Math.random() * anims.length)];

            card.style.animationName = randomAnim;
            // Faster speed: 1s to 3s cycle (Mobile)
            card.style.animationDuration = isMobile ? (1 + Math.random() * 2) + 's' : (2 + Math.random() * 2) + 's';
            card.style.animationDelay = (Math.random() * 1) + 's';
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            const onStart = (e) => {
                isDragging = true;
                // Get touch or mouse position
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                startX = clientX;
                startY = clientY;

                const style = window.getComputedStyle(element);
                initialLeft = parseFloat(style.left);
                initialTop = parseFloat(style.top);

                // Stop animation while dragging
                element.style.animation = 'none';
                element.style.zIndex = 100; // Bring to front
                element.style.cursor = 'grabbing';
            };

            const onMove = (e) => {
                if (!isDragging) return;
                e.preventDefault(); // Stop scrolling

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startX;
                const dy = clientY - startY;

                // Convert pixels to % roughly for the container? 
                // Easier to just use pixels for drag, but let's try to update the left/top styles
                // Since parent is relative, we can add pixels to the computed left/top

                element.style.left = (initialLeft + dx) + 'px';
                element.style.top = (initialTop + dy) + 'px';
            };

            const onEnd = () => {
                if (!isDragging) return;
                isDragging = false;
                element.style.cursor = 'grab';
                element.style.zIndex = '';
                // Optional: Resume animation? User might want it to stay put.
                // Leaving animation off makes it feel like you "placed" it.
            };

            element.addEventListener('mousedown', onStart);
            element.addEventListener('touchstart', onStart, { passive: false });

            window.addEventListener('mousemove', onMove);
            window.addEventListener('touchmove', onMove, { passive: false });

            window.addEventListener('mouseup', onEnd);
            window.addEventListener('touchend', onEnd);
        }

        // Init first tab on load
        document.addEventListener('DOMContentLoaded', () => {
            const startTab = document.querySelector('.sidebar-item.active');
            if (startTab) switchTab(startTab, 'dashboard');
        });
    </script>
</body>

</html>